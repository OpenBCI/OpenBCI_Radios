{
  "_args": [
    [
      {
        "raw": "/Users/andrewkeller/openbci/OpenBCI_NodeJS/openbci-1.1.0.tgz",
        "scope": null,
        "escapedName": null,
        "name": null,
        "rawSpec": "/Users/andrewkeller/openbci/OpenBCI_NodeJS/openbci-1.1.0.tgz",
        "spec": "/Users/andrewkeller/openbci/OpenBCI_NodeJS/openbci-1.1.0.tgz",
        "type": "local"
      },
      "/Users/andrewkeller/Documents/Arduino/libraries/OpenBCI_Radios/test/js"
    ]
  ],
  "_from": "../../../../../../openbci/OpenBCI_NodeJS/openbci-1.1.0.tgz",
  "_id": "openbci@1.1.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/openbci",
  "_phantomChildren": {},
  "_requested": {
    "raw": "/Users/andrewkeller/openbci/OpenBCI_NodeJS/openbci-1.1.0.tgz",
    "scope": null,
    "escapedName": null,
    "name": null,
    "rawSpec": "/Users/andrewkeller/openbci/OpenBCI_NodeJS/openbci-1.1.0.tgz",
    "spec": "/Users/andrewkeller/openbci/OpenBCI_NodeJS/openbci-1.1.0.tgz",
    "type": "local"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "file:../../../../../../openbci/OpenBCI_NodeJS/openbci-1.1.0.tgz",
  "_shasum": "e546c60c3b676eb1c85eb766a34d3a2614089324",
  "_shrinkwrap": null,
  "_spec": "/Users/andrewkeller/openbci/OpenBCI_NodeJS/openbci-1.1.0.tgz",
  "_where": "/Users/andrewkeller/Documents/Arduino/libraries/OpenBCI_Radios/test/js",
  "author": {
    "name": "AJ Keller",
    "email": "aj@pushtheworld.us",
    "url": "www.openbci.com"
  },
  "bugs": {
    "url": "https://github.com/openbci/openbci-js-sdk/issues"
  },
  "dependencies": {
    "buffer-equal": "^1.0.0",
    "gaussian": "^1.0.0",
    "mathjs": "^3.3.0",
    "performance-now": "^0.2.0",
    "serialport": "3.1.2",
    "sntp": "^2.0.0",
    "streamsearch": "^0.1.2"
  },
  "description": "The official Node.js SDK for the OpenBCI Biosensor Board.",
  "devDependencies": {
    "chai": "^3.4.1",
    "chai-as-promised": "^5.2.0",
    "codecov": "^1.0.1",
    "istanbul": "^0.4.4",
    "mocha": "^2.3.4",
    "sandboxed-module": "^2.0.3",
    "sinon": "^1.17.2",
    "sinon-chai": "^2.8.0"
  },
  "directories": {
    "test": "test"
  },
  "engines": {
    "node": ">=4.0.0"
  },
  "homepage": "https://github.com/openbci/openbci-js-sdk#readme",
  "keywords": [
    "openbci",
    "openbci-node"
  ],
  "license": "MIT",
  "main": "openBCIBoard",
  "name": "openbci",
  "optionalDependencies": {},
  "readme": "[![Stories in Ready](https://badge.waffle.io/OpenBCI/OpenBCI_NodeJS.png?label=ready&title=Ready)](https://waffle.io/OpenBCI/OpenBCI_NodeJS)\n[![Join the chat at https://gitter.im/OpenBCI/OpenBCI_NodeJS](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/OpenBCI/OpenBCI_NodeJS?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Build Status](https://travis-ci.org/OpenBCI/OpenBCI_NodeJS.svg?branch=master)](https://travis-ci.org/OpenBCI/OpenBCI_NodeJS)\n[![codecov](https://codecov.io/gh/OpenBCI/OpenBCI_NodeJS/branch/master/graph/badge.svg)](https://codecov.io/gh/OpenBCI/OpenBCI_NodeJS)\n\n# OpenBCI Node.js SDK\n\nA Node.js module for OpenBCI ~ written with love by [Push The World!](http://www.pushtheworldllc.com)\n\nWe are proud to support all functionality of the OpenBCI 8 and 16 Channel boards and are actively developing and maintaining this module.\n\nThe purpose of this module is to **get connected** and **start streaming** as fast as possible.\n\n## TL;DR\n\n#### Install via npm:\n\n```\nnpm install openbci\n```\n\n#### Get connected and start streaming\n\n```js\nvar OpenBCIBoard = require('openbci').OpenBCIBoard;\nvar ourBoard = new OpenBCIBoard();\nourBoard.connect(portName)\n    .then(function() {\n        ourBoard.on('ready',function() {\n            ourBoard.streamStart();\n            ourBoard.on('sample',function(sample) {\n                /** Work with sample */\n                for (var i = 0; i < ourBoard.numberOfChannels(); i++) {\n                    console.log(\"Channel \" + (i + 1) + \": \" + sample.channelData[i].toFixed(8) + \" Volts.\");\n                    // prints to the console\n                    //  \"Channel 1: 0.00001987 Volts.\"\n                    //  \"Channel 2: 0.00002255 Volts.\"\n                    //  ...\n                    //  \"Channel 8: -0.00001875 Volts.\"\n                }\n            });\n        });\n})\n```\n\nWant to know if the module really works? Check out some projects and organizations using it:\n\n* [_OpenEXP_](https://github.com/openexp/OpenEXP): an open-source desktop app for running experiments and collecting behavioral and physiological data.\n* [_Thinker_](http://www.pushtheworldllc.com/#!thinker/uc1fn): a project building the world's first brainwave-word database.\n* [_NeuroJS_](https://github.com/NeuroJS): a community dedicated to Neuroscience research using JavaScript, they have several great examples.\n\nStill not satisfied it works?? Check out this [detailed report](http://s132342840.onlinehome.us/pushtheworld/files/voltageVerificationTestPlanAndResults.pdf) that scientifically validates the output voltages of this module.\n\nHow are you still doubting and not using this already? Fine, go look at some of the [400 **_automatic_** tests](https://codecov.io/github/OpenBCI/openbci-js-sdk?branch=master) written for it!\n\n## General Overview\n\nInitialization\n--------------\n\nInitializing the board:\n\n```js\nvar OpenBCIBoard = require('openbci');\nvar ourBoard = new OpenBCIBoard.OpenBCIBoard();\n```\n\nFor initializing with options, such as verbose print outs:\n\n```js\nvar OpenBCIBoard = require('openbci').OpenBCIBoard;\nvar ourBoard = new OpenBCIBoard({\n    verbose: true\n});\n```\n\nOr if you don't have a board and want to use synthetic data:\n\n```js\nvar OpenBCIBoard = require('openbci').OpenBCIBoard;\nvar ourBoard = new OpenBCIBoard({\n    simulate: true\n});\n```\n\nAnother useful way to start the simulator:\n```js\nvar openBCIBoard = require('openbci');\nvar k = openBCIBoard.OpenBCIConstants;\nvar ourBoard = openBCIBoard.OpenBCIBoard();\nourBoard.connect(k.OBCISimulatorPortName) // This will set `simulate` to true\n    .then(function(boardSerial) {\n        ourBoard.on('ready',function() {\n            /** Start streaming, reading registers, what ever your heart desires  */\n        });\n    }).catch(function(err) {\n        /** Handle connection errors */\n    });\n```\n\n\n'ready' event\n------------\n\nYou MUST wait for the 'ready' event to be emitted before streaming/talking with the board. The ready happens asynchronously\nso installing the 'sample' listener and writing before the ready event might result in... nothing at all.\n\n```js\nvar OpenBCIBoard = require('openbci').OpenBCIBoard;\nvar ourBoard = new OpenBCIBoard();\nourBoard.connect(portName).then(function(boardSerial) {\n    ourBoard.on('ready',function() {\n        /** Start streaming, reading registers, what ever your heart desires  */\n    });\n}).catch(function(err) {\n    /** Handle connection errors */\n});            \n```\n\nSample properties:\n------------------\n* `startByte` (`Number` should be `0xA0`)\n* `sampleNumber` (a `Number` between 0-255)\n* `channelData` (channel data indexed at 0 filled with floating point `Numbers` in Volts)\n* `accelData` (`Array` with X, Y, Z accelerometer values when new data available)\n* `auxData` (`Buffer` filled with either 2 bytes (if time synced) or 6 bytes (not time synced))\n* `stopByte` (`Number` should be `0xCx` where x is 0-15 in hex)\n* `boardTime` (`Number` the raw board time)\n* `timeStamp` (`Number` the `boardTime` plus the NTP calculated offset)\n\nThe power of this module is in using the sample emitter, to be provided with samples to do with as you wish.\n\nYou can also start the simulator by sending `.connect(portName)` with `portName` equal to `'OpenBCISimulator'`.\n\nTo get a 'sample' event, you need to:\n-------------------------------------\n1. Call `.connect(serialPortName)`\n2. Install the 'ready' event emitter on resolved promise\n3. In callback for 'ready' emitter, call `streamStart()`\n4. Install the 'sample' event emitter\n```js\nvar OpenBCIBoard = require('openbci').OpenBCIBoard;\nvar ourBoard = new OpenBCIBoard();\nourBoard.connect(portName).then(function() {\n    ourBoard.on('ready',function() {\n        ourBoard.streamStart();\n        ourBoard.on('sample',function(sample) {\n            /** Work with sample */\n        });\n    });\n}).catch(function(err) {\n    /** Handle connection errors */\n});            \n```\nClose the connection with `.streamStop()` and disconnect with `.disconnect()`\n```js\nvar ourBoard = new require('openbci').OpenBCIBoard();\nourBoard.streamStop().then(ourBoard.disconnect());\n```\n\nTime Syncing\n------------\nYou must be using OpenBCI firmware version 2 in order to do time syncing. After you `.connect()` and send a `.softReset()`, you can call `.usingVersionTwoFirmware()` to get a boolean response as to if you are using `v1` or `v2`.\n\nNow using firmware `v2`, the fun begins! What we set out to do was synchronize not only the board to this modules clock, but also with a global NTP server, so that you could use several different devices and all sync to the same global server. That way you can really do some serious cloud computing!\n\n```js\nvar OpenBCIBoard = require('openbci').OpenBCIBoard,\n    ourBoard = new OpenBCIBoard({\n        verbose:true,\n        timeSync: true // Sync up with NTP servers in constructor\n    });\n\n// Call to connect\nourBoard.connect(portName).then(() => {\n    ourBoard.on('ready',() => {\n        ourBoard.streamStart()\n            .catch(err => {\n                console.log(`stream start: ${err}`);\n            })\n    });\n    // 'synced' event contains the guts of the whole sync operation.\n    ourBoard.on('synced',obj => {\n        console.log('sync obj',obj);\n    });\n    ourBoard.on('sample',sample => {\n        // Resynchronize every 100 samples\n        if (sample.sampleNumber % 100 === 0) {\n            ourBoard.syncClocks();\n        }\n\n        if (sample.timeStamp) { // true after the first sync\n            console.log(`NTP Time Stamp ${sample.timeStamp}`);\n        }\n\n    });\n})\n.catch(err => {\n    console.log(`connect: ${err}`);\n});\n```\n\nAuto-finding boards\n-------------------\nYou must have the OpenBCI board connected to the PC before trying to automatically find it.\n\nIf a port is not automatically found, then call `.listPorts()` to get a list of all serial ports this would be a good place to present a drop down picker list to the user, so they may manually select the serial port name.\n\n```js\nvar OpenBCIBoard = require('openbci').OpenBCIBoard;\nvar ourBoard = new OpenBCIBoard();\nourBoard.autoFindOpenBCIBoard().then(portName => {\n    if(portName) {\n        /**\n        * Connect to the board with portName\n        * i.e. ourBoard.connect(portName).....\n        */\n    } else {\n        /**Unable to auto find OpenBCI board*/\n    }\n});\n```\n\nNote: `.autoFindOpenBCIBoard()` will return the name of the Simulator if you instantiate with option `simulate: true`.\n\nAuto Test - (Using impedance to determine signal quality)\n---------------------------------------------------------\nMeasuring impedance is a vital tool in ensuring great data is collected.\n\n**_IMPORTANT!_** Measuring impedance takes time, so *only test what you must*\n\nYour OpenBCI board will have electrodes hooked up to either a P input, N input or in some cases both inputs.\n\nTo test specific inputs of channels:\n\n1. Connect to board.\n2. Start streaming.\n3. Install the 'impedanceArray' emitter\n4. Call `.impedanceTestChannels()` with your configuration array\n\nA configuration array looks like, for an 8 channel board, `['-','N','n','p','P','-','b','b']`\n\nWhere there are the same number of elements as channels and each element can be either:\n\n* `p` or `P` (only test P input)\n* `n` or `N` (only test N input)\n* `b` or `B` (test both inputs) (takes 66% longer to run then previous two `p` or `n`)\n* `-` (ignore channel)\n\nWithout further ado, here is an example:\n```js\nvar OpenBCIBoard = require('openbci').OpenBCIBoard;\nvar ourBoard = new OpenBCIBoard();\nourBoard.connect(portName).then(function(boardSerial) {\n    ourBoard.on('ready',function() {\n        ourBoard.streamStart();\n        ourBoard.once('impedanceArray', impedanceArray => {\n            /** Work with impedance Array */\n        });\n        ourBoard.impedanceTestChannels(['n','N','n','p','P','p','b','B']).catch(err => console.log(err));\n    });\n}).catch(function(err) {\n    /** Handle connection errors */\n});\n```\n\nBut wait! What is this `impedanceArray`? An Array of Objects, for each object:\n```js\n[{\n    channel: 1,\n    P: {\n        raw: -1,\n        text: 'init'\n    },\n    N: {\n        raw: -1,\n        text: 'init'\n    }\n},\n{\n    // Continues for each channel up to the amount of channels on board (8 or 16)\n},...];\n```\n\nWhere:\n\n* *channel* is the channel number (`impedanceArray[0]` is channel 1, `impedanceArray[6]` is channel 7)\n* *P* is the P input data (Note: P is capitalized)\n  * *raw* is an impedance value resulting from the Goertzel algorithm.\n  * *text* is a text interpretation of the `average`\n    * **Good** impedance is < 5k Ohms\n    * **Ok** impedance is 5 to 10k Ohms\n    * **Bad** impedance is > 10k Ohms\n    * **None** impedance is > 1M Ohms\n* *N* is the N input data (Note: N is capitalized) (see above for what N object consists of)\n\nTo run an impedance test on all inputs, one channel at a time:\n\n1. Connect to board\n2. Start streaming\n3. Install the 'impedanceObject'\n4. Call `.impedanceTestAllChannels()`\n\n**Note: Takes up to 5 seconds to start measuring impedances. There is an unknown number of samples taken. Not always 60!**\n\nFor example:\n\n```js\nvar OpenBCIBoard = require('openbci').OpenBCIBoard;\nvar ourBoard = new OpenBCIBoard();\nourBoard.connect(portName).then(function(boardSerial) {\n    ourBoard.streamStart();\n    ourBoard.on('impedanceArray', impedanceArray => {\n        /** Work with impedance */\n    });\n    ourBoard.impedanceTestAllChannels();\n}\n```\n\nSee Reference Guide for a complete list of impedance tests.\n\nReference Guide\n---------------\n## Methods\n\n### OpenBCIBoard (options)\n\nCreate new instance of an OpenBCI board.\n\n**_options (optional)_**\n\nBoard optional configurations.\n\n* `baudRate` {Number} - Baud Rate, defaults to 115200. Manipulating this is allowed if firmware on board has been previously configured.\n* `boardType` {String} - Specifies type of OpenBCI board (3 possible boards)\n  * `default` - 8 Channel OpenBCI board (Default)\n  * `daisy` - 8 Channel board with Daisy Module - 16 Channels\n  * `ganglion` - 4 Channel board\n    (NOTE: THIS IS IN-OP TIL RELEASE OF GANGLION BOARD 08/2016)\n* `simulate` {Boolean} - Full functionality, just mock data. Must attach Daisy module by setting `simulatorDaisyModuleAttached` to `true` in order to get 16 channels. (Default `false`)\n* `simulatorBoardFailure` {Boolean} - Simulates board communications failure. This occurs when the RFduino on the board is not polling the RFduino on the dongle. (Default `false`)\n* `simulatorDaisyModuleAttached` {Boolean} - Simulates a daisy module being attached to the OpenBCI board. This is useful if you want to test how your application reacts to a user requesting 16 channels but there is no daisy module actually attached, or vice versa, where there is a daisy module attached and the user only wants to use 8 channels. (Default `false`)\n* `simulatorFirmwareVersion` {String} - Allows the simulator to use firmware version 2 features. (2 Possible Options)\n  * `v1` - Firmware Version 1 (Default)\n  * `v2` - Firmware Version 2\n* `simulatorHasAccelerometer` - {Boolean} - Sets simulator to send packets with accelerometer data. (Default `true`)\n* `simulatorInjectAlpha` - {Boolean} - Inject a 10Hz alpha wave in Channels 1 and 2 (Default `true`)\n* `simulatorInjectLineNoise` {String} - Injects line noise on channels. (3 Possible Options)\n  * `60Hz` - 60Hz line noise (Default) [America]\n  * `50Hz` - 50Hz line noise [Europe]\n  * `None` - Do not inject line noise.\n* `simulatorSampleRate` {Number} - The sample rate to use for the simulator. Simulator will set to 125 if `simulatorDaisyModuleAttached` is set `true`. However, setting this option overrides that setting and this sample rate will be used. (Default is `250`)\n* `simulatorSerialPortFailure` {Boolean} - Simulates not being able to open a serial connection. Most likely due to a OpenBCI dongle not being plugged in.\n* `sntpTimeSync` - {Boolean} Syncs the module up with an SNTP time server and uses that as single source of truth instead of local computer time. (Default `true`)\n* `verbose` {Boolean} - Print out useful debugging events\n\n**Note, we have added support for either all lowercase OR camel case for the options, use whichever style you prefer.**\n\n### .autoFindOpenBCIBoard()\n\nAutomatically find an OpenBCI board.\n\n**Note: This will always return an Array of `COM` ports on Windows**\n\n**_Returns_** a promise, fulfilled with a `portName` such as `/dev/tty.*` on Mac/Linux or `OpenBCISimulator` if `this.options.simulate === true`.\n\n### .channelOff(channelNumber)\n\nTurn off a specified channel\n\n**_channelNumber_**\n\nA number (1-16) specifying which channel you want to turn off.\n\n**_Returns_** a promise, fulfilled if the command was sent to the write queue.\n\n### .channelOn(channelNumber)\n\nTurn on a specified channel\n\n**_channelNumber_**\n\nA number (1-16) specifying which channel you want to turn on.\n\n**_Returns_** a promise, fulfilled if the command was sent to the write queue.\n\n### .channelSet(channelNumber,powerDown,gain,inputType,bias,srb2,srb1)\n\nSend a channel setting command to the board.\n\n**_channelNumber_**  \n\nDetermines which channel to set. It's a 'Number' (1-16)\n\n**_powerDown_**\n\nPowers the channel up or down. It's a 'Bool' where `true` turns the channel off and `false` turns the channel on (default)\n\n**_gain_**\n\nSets the gain for the channel. It's a 'Number' that is either (1,2,4,6,8,12,24(default))\n\n**_inputType_**\n\nSelects the ADC channel input source. It's a 'String' that **MUST** be one of the following: \"normal\", \"shorted\", \"biasMethod\" , \"mvdd\" , \"temp\" , \"testsig\", \"biasDrp\", \"biasDrn\".\n\n**_bias_**\n\nSelects if the channel shall include the channel input in bias generation. It's a 'Bool' where `true` includes the channel in bias (default) or `false` it removes it from bias.\n\n**_srb2_**\n\nSelect to connect (`true`) this channel's P input to the SRB2 pin. This closes a switch between P input and SRB2 for the given channel, and allows the P input to also remain connected to the ADC. It's a 'Bool' where `true` connects this input to SRB2 (default) or `false` which disconnect this input from SRB2.\n\n**_srb1_**\n\nSelect to connect (`true`) all channels' N inputs to SRB1. This effects all pins, and disconnects all N inputs from the ADC. It's a 'Bool' where `true` connects all N inputs to SRB1 and `false` disconnects all N inputs from SRB1 (default).\n\n**_Returns_** a promise fulfilled if proper commands sent to the write queue, rejects on bad input or no board.\n\n**Example**\n```js\nourBoard.channelSet(2,false,24,'normal',true,true,false);\n// sends ['x','2','0','6','0','1','1','0','X'] to the command queue\n```\n\n### .connect (portName)\n\nThe essential precursor method to be called initially to establish a serial connection to the OpenBCI board.\n\n**_portName_**\n\nThe system path of the OpenBCI board serial port to open. For example, `/dev/tty` on Mac/Linux or `COM1` on Windows.\n\n**_Returns_** a promise, fulfilled by a successful serial connection to the board.\n\n### .debugSession()\n\nCalls all `.printPacketsBad()`, `.printPacketsRead()`, `.printBytesIn()`\n\n### .disconnect()\n\nCloses the serial port opened by `.connect()`.  Waits for stop streaming command to be sent if currently streaming.\n\n**_Returns_** a promise, fulfilled by a successful close of the serial port object, rejected otherwise.\n\n### .getSettingsForChannel(channelNumber)\n\nGets the specified channelSettings register data from printRegisterSettings call.\n\n**_channelNumber_**\n\nA number specifying which channel you want to get data on. Only 1-8 at this time.\n\n**Note, at this time this does not work for the daisy board**\n\n**_Returns_** a promise, fulfilled if the command was sent to the board and the `.processBytes()` function is ready to reach for the specified channel.\n\n### .impedanceTestAllChannels()\n\nTo apply test signals to the channels on the OpenBCI board used to test for impedance. This can take a little while to actually run (<8 seconds)!\n\nDon't forget to install the `impedanceArray` emitter to receive the impendances!\n\n**Note, you must be connected in order to set the test commands. Also this method can take up to 5 seconds to send all commands!**\n\n**_Returns_** a promise upon completion of test.  \n\n### .impedanceTestChannels(arrayOfCommands)\n\n**_arrayOfCommands_**\n\nThe array of configurations where there are the same number of elements as channels and each element can be either:\n\n* `p` or `P` (only test P input)\n* `n` or `N` (only test N input)\n* `b` or `B` (test both inputs) (takes 66% longer to run then previous two `p` or `n`)\n* `-` (ignore channel)\n\nDon't forget to install the `impedanceArray` emitter to receive the impendances!\n\n**Note, you must be connected in order to set the test commands. Also this method can take up to 5 seconds to send all commands!**\n\n**_Returns_** a promise upon completion of test.  \n\n### .impedanceTestChannel(channelNumber)\n\nRun a complete impedance test on a single channel, applying the test signal individually to P & N inputs.\n\n**_channelNumber_**\n\nA Number, specifies which channel you want to test.\n\n**_Returns_** a promise that resolves a single channel impedance object.\n\nExample:\n```js\nvar OpenBCIBoard = require('openbci').OpenBCIBoard;\nvar ourBoard = new OpenBCIBoard();\nourBoard.connect(portName).then(function(boardSerial) {\n    ourBoard.on('ready',function() {\n        ourBoard.streamStart();\n        ourBoard.impedanceTestChannel(1)\n            .then(impedanceObject => {\n                /** Do something with impedanceObject! */\n            })\n            .catch(err => console.log(err));\n    });\n}).catch(function(err) {\n    /** Handle connection errors */\n});\n```\nWhere an impedance for this method call would look like:\n```js\n{\n    channel: 1,\n    P: {\n        raw: 2394.45,\n        text: 'good'\n    },\n    N: {\n        raw: 7694.45,\n        text: 'ok'\n    }\n}\n```\n\n### .impedanceTestChannelInputP(channelNumber)\n\nRun impedance test on a single channel, applying the test signal only to P input.\n\n**_channelNumber_**\n\nA Number, specifies which channel you want to test.\n\n**_Returns_** a promise that resolves a single channel impedance object.\n\nExample:\n```js\nvar OpenBCIBoard = require('openbci').OpenBCIBoard;\nvar ourBoard = new OpenBCIBoard();\nourBoard.connect(portName).then(function(boardSerial) {\n    ourBoard.on('ready',function() {\n        ourBoard.streamStart();\n        ourBoard.impedanceTestChannelInputP(1)\n            .then(impedanceObject => {\n                /** Do something with impedanceObject! */\n            })\n            .catch(err => console.log(err));\n    });\n}).catch(function(err) {\n    /** Handle connection errors */\n});\n```\nWhere an impedance for this method call would look like:\n```js\n{\n    channel: 1,\n    P: {\n        raw: 2394.45,\n        text: 'good'\n    },\n    N: {\n        raw: -1,\n        text: 'init'\n    }\n}\n```\n\n### .impedanceTestChannelInputN(channelNumber)\n\nRun impedance test on a single channel, applying the test signal only to N input.\n\n**_channelNumber_**\n\nA Number, specifies which channel you want to test.\n\n**_Returns_** a promise that resolves a single channel impedance object.\n\nExample:\n```js\nvar OpenBCIBoard = require('openbci').OpenBCIBoard;\nvar ourBoard = new OpenBCIBoard();\nourBoard.connect(portName).then(function(boardSerial) {\n    ourBoard.on('ready',function() {\n        ourBoard.streamStart();\n        ourBoard.impedanceTestChannelInputN(1)\n            .then(impedanceObject => {\n                /** Do something with impedanceObject! */\n            })\n            .catch(err => console.log(err));\n    });\n}).catch(function(err) {\n    /** Handle connection errors */\n});\n```\nWhere an impedance for this method call would look like:\n```js\n{\n    channel: 1,\n    P: {\n        raw: -1,\n        text: 'init'\n    },\n    N: {\n        raw: 7694.45,\n        text: 'ok'\n    }\n}\n```\n\n### .impedanceTestContinuousStart()\n\nSends command to turn on impedances for all channels and continuously calculate their impedances.\n\n**_Returns_** a promise, that fulfills when all the commands are sent to the internal write buffer\n\n### .impedanceTestContinuousStop()\n\nSends command to turn off impedances for all channels and stop continuously calculate their impedances.\n\n**_Returns_** a promise, that fulfills when all the commands are sent to the internal write buffer\n\n### .listPorts()\n\nList available ports so the user can choose a device when not automatically found.\n\n**_Returns_** a promise, fulfilled with a list of available serial ports.\n\n### .numberOfChannels()\n\nGet the current number of channels available to use. (i.e. 8 or 16).\n\n**Note: This is dependent on if you configured the board correctly on setup options. Specifically as a daisy.**\n\n**_Returns_** a number, the total number of available channels.\n\n### .printBytesIn()\n\nPrints the total number of bytes that were read in this session to the console.\n\n### .printPacketsBad()\n\nPrints the total number of packets that were not able to be read in this session to the console.\n\n### .printPacketsRead()\n\nPrints the total number of packets that were read in this session to the console.\n\n### .printRegisterSettings()\n\nPrints all register settings for the ADS1299 and the LIS3DH on the OpenBCI board.\n\n**_Returns_** a promise, fulfilled if the command was sent to the write queue.\n\n### .radioBaudRateSet(speed)\n\nUsed to set the OpenBCI Host (Dongle) baud rate. With the RFduino configuration, the Dongle is the Host and the Board is the Device. Only the Device can initiate a communication between the two entities. There exists a detrimental error where if the Host is interrupted by the radio during a Serial write, then all hell breaks loose. So this is an effort to eliminate that problem by increasing the rate at which serial data is sent from the Host to the Serial driver. The rate can either be set to default or fast. Further the function should reject if currently streaming. Lastly and more important, if the board is not running the new firmware then this functionality does not exist and thus this method will reject. If the board is using firmware 2+ then this function should resolve the new baud rate after closing the current serial port and reopening one.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_speed_**\n\n{String} - The baud rate that to switch to. Can be either `default` (115200) or `fast` (230400).\n\n**_Returns_** {Promise} - Resolves a {Number} that is the new baud rate, rejects on error.\n\n### .radioChannelGet()\n\nUsed to query the OpenBCI system for it's radio channel number. The function will reject if not connected to the serial port of the dongle. Further the function should reject if currently streaming. Lastly and more important, if the board is not running the new firmware then this functionality does not exist and thus this method will reject. If the board is using firmware 2+ then this function should resolve an Object. See `returns` below.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_Returns_** {Promise} - Resolve an object with keys `channelNumber` which is a Number and `err` which contains an error in the condition that there system is experiencing board communications failure.\n\n### .radioChannelSet(channelNumber)\n\nUsed to set the system radio channel number. The function will reject if not connected to the serial port of the dongle. Further the function should reject if currently streaming. Lastly and more important, if the board is not running the new firmware then this functionality does not exist and thus this method will reject. If the board is using firmware 2+ then this function should resolve.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_channelNumber_**\n\n{Number} - The channel number you want to set to, 1-25.\n\n**_Returns_** {Promise} - Resolves with the new channel number, rejects with err.\n\n### .radioChannelSetHostOverride(channelNumber)\n\nUsed to set the ONLY the radio dongle Host channel number. This will fix your radio system if your dongle and board are not on the right channel and bring down your radio system if you take your dongle and board are not on the same channel. Use with caution! The function will reject if not connected to the serial port of the dongle. Further the function should reject if currently streaming. Lastly and more important, if the board is not running the new firmware then this functionality does not exist and thus this method will reject. If the board is using firmware 2+ then this function should resolve.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_channelNumber_**\n\n{Number} - The channel number you want to set to, 1-25.\n\n**_Returns_** {Promise} - Resolves with the new channel number, rejects with err.\n\n### .radioPollTimeGet()\n\nUsed to query the OpenBCI system for it's device's poll time. The function will reject if not connected to the serial port of the dongle. Further the function should reject if currently streaming. Lastly and more important, if the board is not running the new firmware then this functionality does not exist and thus this method will reject. If the board is using firmware 2+ then this function should resolve the poll time when fulfilled. It's important to note that if the board is not on, this function will always be rejected with a failure message.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_Returns_** {Promise} - Resolves with the new poll time, rejects with err.\n\n### .radioPollTimeSet(pollTime)\n\nUsed to set the OpenBCI poll time. With the RFduino configuration, the Dongle is the Host and the Board is the Device. Only the Device can initiate a communication between the two entities. Therefore this sets the interval at which the Device polls the Host for new information. Further the function should reject if currently streaming. Lastly and more important, if the board is not running the new firmware then this functionality does not exist and thus this method will reject. If the board is using firmware 2+ then this function should resolve.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_pollTime_**\n\n{Number} - The poll time you want to set to, 0-255.\n\n**_Returns_** {Promise} - Resolves with the new channel number, rejects with err.\n\n### .radioSystemStatusGet()\n\nUsed to ask the Host if it's radio system is up. This is useful to quickly determine if you are in fact ready to start trying to connect and such. The function will reject if not connected to the serial port of the dongle. Further the function should reject if currently streaming. Lastly and more important, if the board is not running the new firmware then this functionality does not exist and thus this method will reject. If the board is using firmware +v2.0.0 and the radios are both on the same channel and powered, then this will resolve true.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_Returns_** {Promise} - Resolves true if both radios are powered and on the same channel; false otherwise.\n\n### .sampleRate()\n\nGet the current sample rate.\n\n**Note: This is dependent on if you configured the board correctly on setup options. Specifically as a daisy.**\n\n**_Returns_** a number, the current sample rate.\n\n### .sdStart(recordingDuration)\n\nStart logging to the SD card. If you are not streaming when you send this command, then you should expect to get a success or failure message followed by and end of transmission `$$$`.\n\n**_recordingDuration_**\n\nThe duration you want to log SD information for. Opens a new SD file to write into. Limited to:\n\n * `14sec` - 14 seconds\n * `5min` - 5 minutes\n * `15min` - 15 minutes\n * `30min` - 30 minutes\n * `1hour` - 1 hour\n * `2hour` - 2 hour\n * `4hour` - 4 hour\n * `12hour` - 12 hour\n * `24hour` - 24 hour\n\n**Note: You must have the proper type of SD card inserted into the board for logging to work.**\n\n**_Returns_** resolves if the command was added to the write queue.\n\n### .sdStop()\n\nStop logging to the SD card and close any open file. If you are not streaming when you send this command, then you should expect to get a success or failure message followed by and end of transmission `$$$`. The success message contains a lot of useful information about what happened when writing to the SD card.\n\n**_Returns_** resolves if the command was added to the write queue.\n\n### .simulatorEnable()\n\nTo enter simulate mode. Must call `.connect()` after.\n\n**Note, must be called after the constructor.**\n\n**_Returns_** a promise, fulfilled if able to enter simulate mode, reject if not.\n\n### .simulatorDisable()\n\nTo leave simulate mode.\n\n**Note, must be called after the constructor.**\n\n**_Returns_** a promise, fulfilled if able to stop simulate mode, reject if not.\n\n### .sntp\n\nExtends the popular STNP package on [npmjs](https://www.npmjs.com/package/sntp)\n\n### .sntpGetOffset()\n\nStateful method for querying the current offset only when the last one is too old. (defaults to daily)\n\n**_Returns_** a promise with the time offset\n\n### .sntpGetServerTime()\n\nGet time from the SNTP server. Must have internet connection!\n\n**_Returns_** a promise fulfilled with time object\n\n### .sntpStart()\n\nThis starts the SNTP server and gets it to remain in sync with the SNTP server;\n\n**_Returns_** a promise if the module was able to sync with NTP server.\n\n### .sntpStop()\n\nStops the SNTP from updating\n\n### .softReset()\n\nSends a soft reset command to the board.\n\n**Note, this method must be sent to the board before you can start streaming. This triggers the initial 'ready' event emitter.**\n\n**_Returns_** a promise, fulfilled if the command was sent to the write queue.\n\n### .streamStart()\n\nSends a start streaming command to the board.\n\n**Note, You must have called and fulfilled `.connect()` AND observed a `'ready'` emitter before calling this method.**\n\n**_Returns_** a promise, fulfilled if the command was sent to the write queue, rejected if unable.\n\n### .streamStop()\n\nSends a stop streaming command to the board.\n\n**Note, You must have called and fulfilled `.connect()` AND observed a `'ready'` emitter before calling this method.**\n\n**_Returns_** a promise, fulfilled if the command was sent to the write queue, rejected if unable.\n\n### .syncClocks()\n\nSend the command to tell the board to start the syncing protocol. Must be connected, streaming and using version +2 firmware.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_Returns_** {Promise} resolves if the command was sent to the write queue, rejects if unable.\n\n### .testSignal(signal)\n\nApply the internal test signal to all channels.\n\n**_signal_**\n\nA String indicating which test signal to apply\n\n * `dc` - Connect to DC signal\n * `ground` - Connect to internal GND (VDD - VSS)\n * `pulse1xFast` - Connect to test signal 1x Amplitude, fast pulse\n * `pulse1xSlow` - Connect to test signal 1x Amplitude, slow pulse\n * `pulse2xFast` - Connect to test signal 2x Amplitude, fast pulse\n * `pulse2xFast` - Connect to test signal 2x Amplitude, slow pulse\n * `none` - Reset to default\n\n**_Returns_** a promise, if the commands were sent to write buffer.\n\n### .time()\n\nUses `._sntpNow()` time when sntpTimeSync specified in options, or else use Date.now() for time.\n\n**_Returns_** time since UNIX epoch in ms.\n\n### .usingVersionTwoFirmware()\n\nConvenience method to determine if you can use firmware v2.x.x capabilities.\n\n**Note, should be called after a `.softReset()` because we can parse the output of that to determine if we are using firmware version 2.**\n\n**_Returns_** a boolean, true if using firmware version 2 or greater.\n\n### .write(dataToWrite)\n\nSend commands to the board. Due to the OpenBCI board firmware 1.0, a 10ms spacing **must** be observed between every command sent to the board. This method handles the timing and spacing between characters by adding characters to a global write queue and pulling from it every 10ms. If you are using firmware version +2.0 then you no spacing will be used.\n\n**_dataToWrite_**\n\nEither a single character or an Array of characters\n\n**_Returns_** a promise, fulfilled if the board has been connected and `dataToWrite` has been added to the write queue, rejected if there were any problems.\n\n**Example**\n\nSends a single character command to the board.\n```js\n// ourBoard has fulfilled the promise on .connected() and 'ready' has been observed previously\nourBoard.write('a');\n```\n\nSends an array of bytes\n```js\n// ourBoard has fulfilled the promise on .connected() and 'ready' has been observed previously\nourBoard.write(['x','0','1','0','0','0','0','0','0','X']);\n```\n\nTaking full advantage of the write queue. The following would be sent at t = 0, 10ms, 20ms, 30ms\n```js\nourBoard.write('t');\nourBoard.write('a');\nourBoard.write('c');\nourBoard.write('o');\n```\n\n## Events\n\n### .on('close', callback)\n\nEmitted when the serial connection to the board is closed.\n\n### .on('error', callback)\n\nEmitted when there is an on the serial port.\n\n### .on('impedanceArray', callback)\n\nEmitted when there is a new impedanceArray available.\n\n### .on('query', callback)\n\nEmitted resulting in a call to `.getChannelSettings()` with the channelSettingsObject\n\n### .on('rawDataPacket', callback)\n\nEmitted when there is a new raw data packet available.\n\n### .on('ready', callback)\n\nEmitted when the board is in a ready to start streaming state.\n\n### .on('sample', callback)\n\nEmitted when there is a new sample available.\n\n## Properties\n\n### connected\n\nA bool, true if connected to an OpenBCI board, false if not.\n\n### streaming\n\nA bool, true if streaming data from an OpenBCI board, false if not.\n\n## Useful Constants\n\nTo use the constants file simply:\n```js\nvar openBCIBoard = require('openbci');\nvar k = openBCIBoard.OpenBCIConstants;\n\nconsole.log(k.OBCISimulatorPortName); // prints OpenBCISimulator to the console.\n```\n\n### .OBCISimulatorPortName\n\nThe name of the simulator port.\n\n## Dev Notes\nRunning\n-------\n1. `npm install -D`\n2. Plug usb module into serial port\n3. Turn OpenBCI device on\n4. Type `npm start` into the terminal in the project directory\n\nTesting\n-------\n```\nnpm test\n```\n\n## Contribute to the library\n1. Fork it!\n2. Create your feature branch: `git checkout -b my-new-feature`\n3. Make changes and ensure tests all pass. (`npm test`)\n4. Commit your changes: `git commit -m 'Add some feature'`\n5. Push to the branch: `git push origin my-new-feature`\n6. Submit a pull request :D\n\n## License\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/openbci/openbci-js-sdk.git"
  },
  "scripts": {
    "start": "node index",
    "test": "mocha test",
    "test-cov": "istanbul cover ./node_modules/mocha/bin/_mocha -- -R spec && codecov"
  },
  "version": "1.1.0"
}
